package api

import (
	"bytes"
	"crypto/md5"
	"crypto/tls"
	b64 "encoding/base64"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"sort"
	"strings"
	"time"
	"unsafe"

	"github.com/gorilla/mux"
	"github.com/lonng/nex"
	"gitlab.com/wolfplus/gamespace-lobby/db"
	"gitlab.com/wolfplus/gamespace-lobby/helper"
)

// return url
// /payment/updateuser

// 打款功能
// https://payment.funpay.asia/fun/payment/offlinePay

const (
	// sandbox
	API_VCDESTROY    string = "https://payment.funpay.asia/fun/payment/virtualCard/destroy"
	API_VCCREATE     string = "https://payment.funpay.asia/fun/payment/virtualCard/create"
	API_VCOFFLINEPAY string = "https://payment.funpay.asia/fun/payment/offlinePay"
	domain           string = "http://199.115.228.247:12307"
	secretkey        string = "aHc7j6vY5aZbRe088mUT69X90Ac9GUGv3OoZz4T0"
	merchantID       int16  = 1899
	businessID       int16  = 960
	feeID            int16  = 930
	feeName          string = "test" // 计费点名称
	currency         string = "VND"
	// vc 10 mins
)

var (
	giftPacks = []*giftPack{
		&giftPack{GameCoinAmount: 50000, PurchaseAmount: 100000},
		&giftPack{GameCoinAmount: 500000, PurchaseAmount: 500000},
		&giftPack{GameCoinAmount: 1000000, PurchaseAmount: 1000000},
		&giftPack{GameCoinAmount: 5000000, PurchaseAmount: 5000000},
		&giftPack{GameCoinAmount: 10000000, PurchaseAmount: 10000000},
		&giftPack{GameCoinAmount: 20000000, PurchaseAmount: 20000000},
	}
)

type giftPack struct {
	PurchaseAmount int64 `json:"purchaseAmount"`
	GameCoinAmount int64 `json:"gameCoinAmount"`
}

type response1 struct { // what the api returns
	Code   int         `json:"code"`
	Msg    string      `json:"msg"`
	Result interface{} `json:"result"`
}

func _destroy_vc(orderNo string) { // orderNo is order_id in order table
	array1 := map[string]interface{}{
		"merchantID": merchantID,
		"businessID": businessID,
		"feeID":      feeID,
		"timestamp":  time.Now().Unix(),
		"orderNo":    orderNo,
		// "bankType":nil,
		"version": 1.3,
	}
	_, err := postData(array1,
		API_VCDESTROY)

	if err != nil {
		logger.Printf("destroy err: %v", err)
	}
}

func getOrdersByUidHandler(r *http.Request) ([]map[string]string, error) {
	uid, isValid := helper.VerifyJWT(r)
	if !isValid {
		return nil, errors.New("Invalid token")
	}

	orders := db.GetOrdersByUid(uid)

	if len(orders) > 0 {
		return orders, nil
	}

	return nil, nil
}

func GetGiftPacksHandler(r *http.Request) ([]*giftPack, error) {
	// logger.Printf("giftPacks: %v", giftPacks)
	return giftPacks, nil
}

// 商家传入的returnUrl POST
func updateOrderHandler(r *http.Request) (map[string]interface{}, error) {
	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Println(err)
	}
	var reqJson response1
	err = json.Unmarshal(reqBody, &reqJson)
	if err != nil {
		log.Println(err)
	}

	// logger.Print("updateOrderHandler")
	// logger.Printf("reqJson: %v", reqJson)

	if resultObj, ok := reqJson.Result.(map[string]interface{}); ok {
		orderID := resultObj["orderNo"].(string)
		if reqJson.Code == 10000 { // success
			// get and update order
				order, updatedAmount := db.UpdateOrder(orderID,
				map[string]string{
					"order_status":           db.ORDERSTATUSPAID, // important only update to paid if code is 10000
					"callbackPurchaseAmount": helper.Int64ToString(int64(resultObj["purchaseAmount"].(float64))),
					"callback_data":          "",
				})
			logger.Printf("order: %v, updatedAmount: %v", order, updatedAmount)
			if order != nil {
				if updatedAmount != 0 {
					// user, _ := db.GetUser(helper.StringToInt64(order["uid"]))
					data := map[string]interface{}{
						"uid":       order["uid"],
						"game_coin": updatedAmount,
					}
					LobbyCoinUpdate(data)
				}

			} else {
				db.UpdateOrder(orderID, map[string]string{
					"comment":      fmt.Sprintf("结果码：%v: %v，付款数额：%v", reqJson.Code, reqJson.Msg, resultObj["purchaseAmount"]),
					"order_status": db.ORDERSTATUSFAILED,
				})
			}

			_, vcok := r.URL.Query()["vc"]
			if vcok {
				_destroy_vc(resultObj["orderNo"].(string))
			}
		} else {
			db.UpdateOrder(orderID, map[string]string{
				"comment": fmt.Sprintf("结果码：%v: %v", reqJson.Code, reqJson.Msg),
			})
		}
	}
	// 回调内容：{"code":10000,"msg":"the request is succeed.","result":{"accountName":"VAP001 ASDF","accountNo":"902000228252","amount":50000,"bankLink":"","bankName":"WOORIBANK","branchBankName":"Hoan kiem","businessID":273,"cityName":"HCM","currency":"VND","expireDate":"","feeID":243,"merchantID":1586,
	// "orderNo":"1","purchaseAmount":50000,"purchaseCurrency":"VND","purchaseTime":"20210414152122","remark":"test","serviceFee":0,"sign":"61154CDF05462AE9B6DD0ADD981D27B9","tradeNo":"003000130020210414162122582971","userName":"asdf"}}
	// orderNo, tradeNo
	// accountNo, accountName, bankName, branchBankName, bankLink 空, cityName, serviceFee,
	// sign, remark
	return nil, nil
}

// params: giftPackId, userName, phoneNumber
func vcPayHandler(r *http.Request) (map[string]interface{}, error) {

	uid, isValid := helper.VerifyJWT(r)
	if !isValid {
		return nil, errors.New("Invalid token")
	}
	reqJson := helper.ReadParameters(r)

	selectedGiftPack := giftPacks[helper.StringToInt(reqJson["giftPackId"])]
	amount := selectedGiftPack.PurchaseAmount

	if existingOrder := db.CheckWaitingOrder(map[string]string{"uid": uid,
		"type": "vc"}); existingOrder != nil {

		jsonObj := response1{}
		json.Unmarshal([]byte(existingOrder["callback_data"]), &jsonObj)

		logger.Printf("created_datetime: %v", existingOrder["created_datetime"])

		layout := "2006-01-02 15:04:05"
		t, _ := time.Parse(layout, existingOrder["created_datetime"]) // order created date time
		// logger.Printf("t: %v", t)
		// logger.Printf("current shanghai time: %v", helper.GetCurrentShanghaiTime())
		t2, _ := time.Parse(layout, helper.GetCurrentShanghaiTimeString()) // current date time
		// logger.Printf("t2: %v", t2)

		diff := t2.UTC().Sub(t.UTC())

		if diff.Minutes() <= 10 {
			return map[string]interface{}{
				"jsonObj": jsonObj,
			}, nil
		} else {
			updateOrderData := map[string]string{
				"order_status": db.ORDERSTATUSFAILED,
			}
			db.UpdateOrder(existingOrder["order_id"], updateOrderData)
			_destroy_vc(existingOrder["order_id"])
		}

	}

	orderID, _ := db.NewOrder(map[string]string{
		"uid":              uid,
		"payment_amount":   helper.Int64ToString(amount),
		"game_coin_amount": helper.Int64ToString(selectedGiftPack.GameCoinAmount),
		"type":             "vc",
	})

	array1 := map[string]interface{}{
		"merchantID": merchantID,
		"businessID": businessID,
		"feeID":      feeID,
		// "clientID":     reqJson["clientID"], //get clientID 终端用户的ID或者合同号等唯一标记
		"timestamp":  time.Now().Unix(),
		"version":    1.3,
		"amount":     amount, // for testing
		"currency":   currency,
		"orderNo":    helper.Int64ToString(orderID),
		"expireDate": helper.GetExpiryDateHanoiTime(), //"20221230120000", // 以河内时间为准。此值暂时无实际意义
		"returnUrl":  domain + "/payment/updateorder?uid=" + uid + "&vc=true",
		// "bankType":   "", // 此值现在已无意义，Funpay会自动选择当前最好的虚拟卡类型返回给用户。
		"accountBase": uid,
		"userName":    reqJson["userName"],    // 用户真实姓名，用于线下便利店跟用户确认核验订单，避免误操作
		"phoneNumber": reqJson["phoneNumber"], // 用户手机号码，用于线下便利店跟用户确认核验订单，避免误操作
		// "IDNo":         reqJson["IDNo"],        // 用户真实身份证号，支持9位和12位身份证号[新增参数]
	}

	jsonObj, err := postData(array1,
		API_VCCREATE)

	payload := map[string]interface{}{
		"jsonObj": jsonObj,
	}
	logger.Printf("jsonObj: %v", jsonObj)
	if err == nil {

		updateOrderData := map[string]string{}
		if jsonObj.Code != 10000 {
			updateOrderData["order_status"] = db.ORDERSTATUSFAILED
			updateOrderData["comment"] = fmt.Sprintf("结果码：%v: %v", jsonObj.Code, jsonObj.Msg)
		} else {
			bytes, err := json.Marshal(jsonObj)
			if err != nil {
				logger.Printf("error converting to string: %v", err)
			}
			updateOrderData["callback_data"] = string(bytes)
		}
		db.UpdateOrder(helper.Int64ToString(orderID), updateOrderData)

		// jsonObj->result is an interface
		if resultObj, ok := jsonObj.Result.(map[string]interface{}); ok {
			// 商家需要将此信息展示给用户: accountNo, accountName, bankName, branchBankName
			// amount 注意此值不是用户实际存入金额
			// accountNo 为该用户分配的 VC号码,
			// accountName 为该用户分配的VC号码户主名称,
			// bankName 该VC归属银行名称,
			// branchBankName 该VC归属银行支行名称
			// bankLink 空, cityName, serviceFee, sign
			logger.Printf("result: %v", resultObj)
		}
	} else {
		logger.Printf("error: %v", err)
	}
	payload["err"] = err
	return payload, err

}

// params: phoneNumber, userName, IDNo, giftPackId
func offlinePayHandler(r *http.Request) (map[string]interface{}, error) {
	logger.Printf("offline pay expire time: %v", helper.GetExpiryDateHanoiTime())

	uid, isValid := helper.VerifyJWT(r)
	if !isValid {
		return nil, errors.New("Invalid token")
	}

	reqJson := helper.ReadParameters(r)
	logger.Printf("reqJson: %v", reqJson)

	selectedGiftPack := giftPacks[helper.StringToInt(reqJson["giftPackId"])]
	amount := selectedGiftPack.PurchaseAmount

	orderID, _ := db.NewOrder(map[string]string{
		"uid":              uid,
		"payment_amount":   helper.Int64ToString(amount),
		"game_coin_amount": helper.Int64ToString(selectedGiftPack.GameCoinAmount),
		"type":             "offline",
	})

	array1 := map[string]interface{}{
		"merchantID": merchantID,
		"businessID": businessID,
		"feeID":      feeID,
		// "clientID":     reqJson["clientID"], //get clientID 终端用户的ID或者合同号等唯一标记
		"timestamp":    time.Now().Unix(),
		"amount":       amount,
		"currency":     currency,
		"name":         feeName,                         // 计费点名称，必须与申请计费点的时候输入的一致
		"orderNo":      helper.Int64ToString(orderID),   // for testing
		"expireDate":   helper.GetExpiryDateHanoiTime(), //"20221230120000",// yyyyMMddHHmmss。超过指定时间后用户将不能再对此订单进行支付。
		"returnUrl":    domain + "/payment/updateorder?uid=" + uid,
		"version":      1.3,                    // 此处是固定值“1.3”，代表API版本V1.3
		"purchaseType": 2,                      // 选择使用的支付方式，此处使用固定值2
		"phoneNumber":  reqJson["phoneNumber"], // 用户手机号码，用于线下便利店跟用户确认核验订单，避免误操作
		"userName":     reqJson["userName"],    // 用户真实姓名，用于线下便利店跟用户确认核验订单，避免误操作
		"IDNo":         reqJson["IDNo"],        // 用户真实身份证号，支持9位和12位身份证号[新增参数]
	}

	if val, ok := reqJson["clientID"]; ok && reqJson["clientID"] != "" {
		array1["clientID"] = val
	}

	jsonObj, err := postData(array1, API_VCOFFLINEPAY)

	payload := map[string]interface{}{
		"jsonObj": jsonObj,
	}
	if err == nil {
		updateOrderData := map[string]string{}
		if jsonObj.Code != 10000 {
			updateOrderData = map[string]string{
				"order_status": db.ORDERSTATUSFAILED,
				"comment":      fmt.Sprintf("结果码：%v: %v", jsonObj.Code, jsonObj.Msg),
			}
		} else {
			bytes, err := json.Marshal(jsonObj)
			if err != nil {
				logger.Printf("error converting to string: %v", err)
			}
			updateOrderData["callback_data"] = string(bytes)
		}
		db.UpdateOrder(helper.Int64ToString(orderID), updateOrderData)

		// jsonObj->result is an interface
		if resultObj, ok := jsonObj.Result.(map[string]interface{}); ok {
			logger.Printf("result: %v", resultObj)
			return payload, nil
		}
	}
	payload["err"] = err
	logger.Printf("error: %v", err)
	return payload, err
}

// no use
func onlinePayHandler(r *http.Request) (map[string]interface{}, error) {
	// uid, isValid := helper.VerifyJWT(r)
	// if !isValid {
	// 	return nil, errors.New("Invalid token")
	// }
	logger.Print("online pay start")
	uid := "111"

	// reqJson := helper.ReadParameters(r)

	array1 := map[string]interface{}{
		"merchantID": 1586,
		"businessID": 273,
		"feeID":      243,
		"timestamp":  time.Now().Unix(),
		"amount":     50000, // for testing
		"currency":   "VND",
		"name":       "testing1", // 计费点名称，必须与申请计费点的时候输入的一致
		"orderNo":    "1",        // for testing
		"returnUrl":  domain + "/payment/updateorder?uid=" + uid,
		"version":    1.3, // 此处是固定值“1.3”，代表API版本V1.3
	}

	var keys = []string{}
	for k := range array1 {
		keys = append(keys, k)
	}
	sort.Sort(Alphabetic(keys))

	string1 := ""
	for i, k := range keys {
		string1 += k + "=" + fmt.Sprintf("%v", array1[k])
		if i+1 != len(keys) {
			string1 += "&"
		}
	}
	string3 := string1
	string1 += secretkey

	logger.Printf("array2: %v", string1)

	hash := md5.Sum([]byte(string1))
	sign := strings.ToUpper(hex.EncodeToString(hash[:]))
	array1["sign"] = sign

	string3 += "&sign=" + sign
	param := b64.StdEncoding.EncodeToString([]byte(string3))

	logger.Printf("array1: %v", array1)
	logger.Printf("string3: %v", string3)
	logger.Printf("param: %v", param)

	bytesData, err := json.Marshal(array1)
	if err != nil {
		logger.Println(err.Error())
		return nil, err
	}

	// logger.Printf("bytesData: %v", bytesData)
	reader := bytes.NewBuffer(bytesData)
	request, err := http.NewRequest("POST",
		"https://sandbox.funpay.asia/fun/payment/onlinePay",
		reader)

	if err != nil {
		logger.Println(err.Error())
		return nil, err
	}

	q := request.URL.Query()
	q.Add("param", param)
	request.URL.RawQuery = q.Encode()
	request.Header.Set("Content-Type", "application/json;charset=UTF-8")

	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := http.Client{Transport: tr}
	resp, err := client.Do(request)

	if err != nil {
		logger.Println(err.Error())
		return nil, err
	}
	respBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		logger.Println(err.Error())
		return nil, err
	}

	str := (*string)(unsafe.Pointer(&respBytes))
	logger.Printf("res: %v", *str)

	payload := map[string]interface{}{
		"ret": str,
	}

	return payload, nil
}

// helpers

func postData(array1 map[string]interface{}, apiString string) (response1, error) {
	signFunPayData(array1)
	logger.Printf("array1: %v", array1)

	jsonObj := response1{}

	bytesData, err := json.Marshal(array1)
	if err != nil {
		logger.Println(err.Error())
		return jsonObj, err
	}

	// logger.Printf("bytesData: %v", bytesData)
	reader := bytes.NewBuffer(bytesData)
	request, err := http.NewRequest("POST",
		apiString,
		reader)

	if err != nil {
		logger.Println(err.Error())
		return jsonObj, err
	}

	request.Header.Set("Content-Type", "application/json;charset=utf-8")

	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := http.Client{Transport: tr}
	resp, err := client.Do(request)

	if err != nil {
		logger.Println(err.Error())
		return jsonObj, err
	}
	respBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		logger.Println(err.Error())
		return jsonObj, err
	}

	str := (*string)(unsafe.Pointer(&respBytes))
	logger.Printf("res: %v", *str)

	json.Unmarshal(respBytes, &jsonObj)

	return jsonObj, nil
}

func signFunPayData(array1 map[string]interface{}) {
	var keys = []string{}
	for k := range array1 {
		keys = append(keys, k)
	}
	sort.Sort(Alphabetic(keys)) // sort by ascii chart

	string1 := ""
	for i, k := range keys {
		string1 += k + "=" + fmt.Sprintf("%v", array1[k])
		if i+1 != len(keys) {
			string1 += "&"
		}
	}
	string1 += secretkey

	logger.Printf("string1: %v", string1)

	hash := md5.Sum([]byte(string1))
	sign := strings.ToUpper(hex.EncodeToString(hash[:]))
	array1["sign"] = sign

}

type Alphabetic []string

func (list Alphabetic) Len() int { return len(list) }

func (list Alphabetic) Swap(i, j int) { list[i], list[j] = list[j], list[i] }

func (list Alphabetic) Less(i, j int) bool {
	var si string = list[i]
	var sj string = list[j]
	var si_lower = []rune(si)
	var sj_lower = []rune(sj)
	// var si_lower = strings.ToLower(si)
	// var sj_lower = strings.ToLower(sj)
	if si_lower[0] == sj_lower[0] {
		return si < sj
	}
	return si_lower[0] < sj_lower[0]
}

func MakePaymentService() http.Handler {
	router := mux.NewRouter()

	router.Handle("/payment/getMyOrders", nex.Handler(getOrdersByUidHandler)).Methods("GET")
	router.Handle("/payment/getGiftPacks", nex.Handler(GetGiftPacksHandler)).Methods("GET")
	router.Handle("/payment/updateorder", nex.Handler(updateOrderHandler)).Methods("POST")
	router.Handle("/payment/vcPay", nex.Handler(vcPayHandler)).Methods("POST")
	router.Handle("/payment/offlinePay", nex.Handler(offlinePayHandler)).Methods("POST")
	router.Handle("/payment/onlinePay", nex.Handler(onlinePayHandler)).Methods("POST") // not used
	// fs := http.FileServer(http.Dir("./static/views/offlinePay/"))
	// router.PathPrefix("/payment/").Handler(http.StripPrefix("/payment/", fs)) // for web test only

	return router
}
